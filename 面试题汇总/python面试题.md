# 1.了解python的内存管理么？

```
python的内存在底层也是由malloc和free的方式来分配和释放，只是它代替程序员决定什么时候分配什么时候释放，
同时也提供接口让用户手动释放，因此它有自己的一套内存管理体系，主要通过两种机制来实现，一个是引用计数，一个是垃圾回收。
前者负责确定当前变量是否需要释放，后者解决前者解决不了的循环引用问题以及提供手动释放的接口

先从较浅的层面来说，Python的内存管理机制可以从三个方面来讲

（1）垃圾回收

（2）引用计数

（3）内存池机制

3.内存池机制

	第-1，-2层主要有操作系统进行操作

	第0层是C中的malloc，free等内存分配和释放函数进行操作；

	第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配内存；

	第3层是最上层，也就是我们对Python对象的直接操作；

	原因：在 C 中如果频繁的调用 malloc 与 free 时,是会产生性能问题的.再加上频繁的分配与释放小块的内存会产生内存碎片。
	具现化：Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。
	Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。


```
# 2.对python迭代器有了解么?
# 3.python的GC了解不？讲一下

```
python中一切皆为对象

1.Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。每一个对象，都维护这一个对指向该对对象的引用的计数。
它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”

2.在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题。
对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。
从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。
标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。
Python使用一个双向链表将这些容器对象组织起来。

3.通过“分代回收”（generation collection）以空间换取时间来进一步提高垃圾回收的效率。Python同时采用了分代(generation)回收的策略。
这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，
但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。
Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。
垃圾回收启动时，一定会扫描所有的0代对象。如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，
那么会启动对0，1，2，即对所有对象进行扫描。这两个次数即上面get_threshold()返回的(700, 10, 10)返回的两个10。也就是说，每10次0代垃圾回收，
会配合1次1代的垃圾回收；而每10次1代的垃圾回收，才会有1次的2代垃圾回收。

参考：http://www.liaogx.com/python-memory-management-and-gc/
```

# 4.装饰器是什么，可以写一个demo吗？

```
装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。
有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。

OCP（开闭原则）原则，在不改变源代码的情况下增加其功能

def begin_end(old):
 
   # 创建一个新函数
    def new_function(*args , **kwargs):
        print('fn3装饰~开始执行~~~~')
        # 调用被扩展的函数
        result = old(*args , **kwargs)
        print('fn3装饰~执行结束~~~~')
        # 返回函数的执行结果
        return result

    # 返回新函数        
    return new_function


@begin_end
def say_hello():
    print('大家好~~~')

say_hello()
```

# 5.对python有了解么，生成器，迭代器说一下区别 
# 6.可迭代对象是？常用的python的标准库有？ 
# 7.python闭包，python用过哪些模块？

```
闭包，顾名思义，就是一个封闭的包裹，里面包裹着自由变量，就像在类里面定义的属性值一样，自由变量的可见范围随同包裹，哪里可以访问到这个包裹，哪里就可以访问到这个自由变量。
即通过闭包，可以在函数外部访问到函数的局部变量

形成闭包的要件
① 函数嵌套
② 将内部函数作为返回值返回
③ 内部函数必须要使用到外部函数的变量

	def make_averager():
	    # 创建一个列表，用来保存数值
	    nums = []
	
	    # 创建一个函数，用来计算平均值
	    def averager(n) :
	        # 将n添加到列表中
	        nums.append(n)
	        # 求平均值
	        return sum(nums)/len(nums)
	
	    return averager
	
	averager = make_averager()
	
	print(averager(10))
	print(averager(20))
	print(averager(30))
	print(averager(40))

```

# 8.Python深拷贝和浅拷贝区别？a=b算是拷贝吗？为什么？

```
Python中对象的赋值都是进行对象引用（内存地址）传递,即指向同一个内存地址

浅拷贝：使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.
深拷贝：如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素，可变对象），可以使用copy.deepcopy()进行深拷贝

对于非容器类型（如数字、字符串、和其他'原子'类型的对象）没有被拷贝一说

参考：http://www.cnblogs.com/wilber2013/p/4645353.html
```
# 9.Python中"is"和"=="的区别 

```
== 比较两个对象的值是否相等
is 比较两个对象是否是同一个对象，比较的是对象的id,即内存地址

[-5,256]除外
a=1000
b=1000
a is b :false
a == b :true
a = b,a is b :true
```
# 10.可变对象与不可变对象？

```
不可变对象:该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，
相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。

可变对象:该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，
并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。

数值类型（int和float）、字符串str、元组tuple都是不可变类型。而列表list、字典dict、集合set是可变类型。
```
# 11.python中的变量类型

```
数值型：
	整数（int）、浮点数（float）、复数
字符串：string
布尔值：bool
列表：list
元组：tuple
字典：dict
集合：set
	
```

# 12.编译型语言和解释型语言

```
计算机是不能够识别高级语言的，所以当我们运行一个高级语言程序的时候，就需要一个“翻译机”来从事把高级语言转变成计算机能读懂的机器语言(二进制码)的过程。
这个过程分成两类，第一种是编译，第二种是解释。 

编译型语言在程序执行之前，先会通过编译器对程序执行一个编译的过程，把程序转变成机器语言。运行时就不需要翻译，而直接执行就可以了，最典型的例子就是C语言。 
解释型语言就没有这个编译过程，而是在程序运行的时候，通过解释器对程序逐行做出解释，然后直接运行。

```

# 13.python递归的最大层数？

```
在pycharm中 递归的最大层数是1000次，无限制的递归调用自己是没有意义的

1、递归必须要有一个明确的结束条件

2、每次进入更深一层递归时，问题规模相比上次递归都有应有所减少

3、递归效率不高，递归层次过多会导致栈溢出
```

# 14.Python的解释器分类：

```
CPython（官方）
    用c语言编写的Python解释器
PyPy
    用Python语言编写的Python解释器
IronPython
    用.net编写的Python解释器
Jython
    用Java编写的Python解释器
```

# 15.*arg和**kwarg作用

```
*arg:接收所有位置参数
**kwarg:接收所有关键字参数
```

# 16.os模块与sys模块

```
os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。
```

















