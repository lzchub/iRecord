<!DOCTYPE html>
<html>
<head>
<title>网络面试题</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
<script type = "text/javascript" > 
//create content
document.addEventListener("DOMContentLoaded", function()
{
    toTop();//置顶

    var div1            = document.createElement("div");
    div1.style.cssText  = "clear:both";

    // create TOC list
    var outline         = document.createElement("div");
    outline.setAttribute("id", "outline-list");
    outline.style.cssText = "border:solid 1px #ccc; background:#eee; min-width:200px;padding:4px 10px;";

    var ele_p           = document.createElement("p");
    ele_p.style.cssText = "text-align: left; margin: 0;";
    outline.appendChild(ele_p);

    var ele_span        = document.createElement("span");

    // ele_span.style.cssText = "float: left;";
    var ele_text        = document.createTextNode("目录");
    ele_span.appendChild(ele_text);

    var ele_a           = document.createElement("a");
    ele_a.appendChild(document.createTextNode("[+]"));
    ele_a.setAttribute("href", "#");
    ele_a.setAttribute("onclick", "javascript:return openct(this);");
    ele_a.setAttribute("title", "Click to Open 目录");

    ele_span.appendChild(ele_a);
    ele_p.appendChild(ele_span);

    var ul_top          = document.createElement("ul"); // 顶级
    ul_top.style.cssText = "display:none;margin-left:14px;padding-left:14px;line-height:160%;";
    ul_top.setAttribute("id", "outline_ol");
    outline.appendChild(ul_top);
    var div1            = document.createElement("div");
    div1.style.cssText  = "clear:both";

    document.body.insertBefore(outline, document.body.childNodes[0]);

    // get all the headlines
    var headers         = document.querySelectorAll('h1,h2,h3,h4,h5,h6');

    if (headers.length < 2)
        return;


    var old_h = 1;

    var ul_array = new Array(7);
    var ul_current = null;
    ul_array[1] = ul_top;

    for (var i = 0; i < headers.length; i++)
    {
        // get H* and prepare for the ordered list 
        var header = headers[i];

        //header.setAttribute("id", "t" + i + header.tagName);
        header.setAttribute("id", header.textContent);
        var h = parseInt(header.tagName.substr(1), 10);

        // assert  1<=h && h <= 6

        ul_current = 0;
        if (h < old_h)
        {
            for (var j = h+1; j <= 6; j++)
            {
                ul_array[j] = null;
            }
            ul_current = h;
        }
        else if (h == old_h)
        {
            ul_current = h;
        }
        else if (h > old_h)
        {
            ul_current = old_h + 1; /* 是old_h + 1的原因： h如果是old_h + 2 或者 + 3时，
                                        我们依然按 + 1来做 */
        }

        if (ul_array[ul_current] == null)
        {
            ul_array[ul_current] = document.createElement("ul");
            if (h>1)
            {
                ul_array[h-1].lastChild.appendChild(ul_array[ul_current]);
            }
        }

        var elem_li = document.createElement("li");
        ul_array[ul_current].appendChild(elem_li);

        var a = document.createElement("a");

        // set href for the TOC item 
        //a.setAttribute("href", "#t" + i + header.tagName);
        a.setAttribute("href", "#" + header.textContent);

        // TOC item text
        //a.innerHTML  = "h" + h + header.textContent;
        a.innerHTML  = header.textContent;


        elem_li.appendChild(a);

        old_h = h;
    }
});
function toTop(){
    var toTop           = document.createElement("div");
    toTop.style.cssText = "position:fixed;bottom:10px;right:10px;width:20x;height:20px;background:gray;padding:5px;";
    toTop.innerHTML="^"
    toTop.setAttribute("id", "toTop");
    toTop.setAttribute("title", "to top");
    document.body.insertBefore(toTop, document.body.childNodes[0]);

    // 获取置顶对象
    var obj = document.getElementById('toTop');

    // 置顶对象点击事件
    obj.onclick = function() {
        var timer = setInterval(function() {
            window.scrollBy(0, -500);
            if(document.documentElement && document.documentElement.scrollTop) //IE
            {
                if(document.documentElement.scrollTop<=0){
                    clearInterval(timer);
                }else{
                    window.scrollBy(0,-500);
                }
            }else{ //Chrome不支持documentElement.scrollTop
                if(document.body.scrollTop<=0){
                    clearInterval(timer);
                }else{
                    window.scrollBy(0,-500);
                }
                if (document.body.scrollTop == 0) {
                    clearInterval(timer);
                };
            }
        }, 2);
    }

    // 窗口滚动检测
    //window.onscroll = function() {
    //    obj.style.display = (document.body.scrollTop >= 300) ? "block" : "none";
    //}
}
// 
function openct(e)
{
    if (e.innerHTML == '[+]')
    {
        // createTextNode
        e.setAttribute('title', 'collapse');
        e.innerHTML         = '[-]';
        var             element = document.getElementById("outline_ol");

        element.style.cssText = "margin-left:14px;padding-left:14px;line-height:160%;";
    }
    else 
    {
        e.setAttribute('title', 'expand');
        e.innerHTML         = '[+]';
        var             element = document.getElementById("outline_ol");

        element.style.cssText = "display:none;margin-left:14px;padding-left:14px;line-height:160%;";
    }

    e.blur();
    return false;
}


</script>

</head>
<body>
<h1 id="1-arp-">1.什么是arp协议？</h1>
<pre><code>ARP协议，全称“Address Resolution Protocol”,中文名是地址解析协议，使用ARP协议可实现通过IP地址获得对应主机的物理地址（MAC地址）。
ARP协议要求通信的主机双方必须在同一个物理网段（即局域网环境）！
</code></pre><h1 id="2-osi-">2.OSI七层模型及简单说明</h1>
<pre><code>物理层： 主要定义物理设备标准，如网线的接口类型、各种传输介质的传输速率等。主要作用是传输比特流
（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是常说的数模与模数转换）。这一层的数据叫做比特（bit），主要设备：集线器。
数据链路层： 主要将从物理层接收的数据进行MAC地址的封装与解封装。常把这层的数据叫做帧，主要设备：网卡，交换机。协议：ARP、RARP
网络层： 选择合适的网间路由和交换节点，确保数据及时传送，将从下层接收到数据进行 IP 地址的封装与解封装。通常把这一层数据叫做数据包，主要设备：路由器。协议：IP、ICMP、IGMP
传输层： 定义了一些传输数据的协议和端口，如TCP、UDP协议，主要将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，以往把这一层数据叫做段。协议：TCP、UDP
会话层： 通过传输层建立数据传输通路。在系统之间发起会话或者接受会话请求（设备之间需要相互认识）。
表示层： 主要是进行对接收的数据进行解释、压缩与解压缩等，即把计算机能够识别的东西转化为人能够识别的东西（如图片、声音等）。
应用层： 主要是一些终端的应用，比如说FTP（各种文件下载）、浏览器、QQ，以及域名系统DNS（将域名解析为IP，及其反解）等，
可以将其理解为在电脑屏幕上可以看到的东西，也就是终端应用。协议：HTTP、DNS、FTP、SMTP...
</code></pre><h1 id="3-tcp-udp-tcp-">3.tcp和udp的区别，tcp的特点</h1>
<pre><code>可以答，tcp面向连接，可靠。udp具有实时性，高效高速传输。tcp是点到点通信，udp支持多对多，简单

TCP/IP 协议是一个协议簇,里面包括 TCP IP 以及 UDP等很多个协议,由于TCP, IP两个比较重要,所以用他们两个命名.

TCP/IP网络模型分为四层: 应用层, 传输层, 网络层, 网络接入层
应用层包括: 超文本传输协议(HTTP),文本传输协议(FTP),远程登录(Telnet)等
传输层包括:为应用提供端到端的通信功能,保证了数据包的传输顺序及数据完整性.两个主要协议就是 TCP 和 UDP
网络层:解决主机到主机的通信问题.该层有三个主要协议:网际协议(IP),互联网组管理协议(IGMP),和互联网控制报文协议(ICMP)
网络接入层:负责监视数据在主机和网络之间的交换

TCP 和 UDP 的区别: 
TCP:Transmission Control Protocol ,传输控制协议,TCP 是面向连接,可靠的,基于字节流的传输层通信协议. 
UDP:User Datagram Protocol,即用户数据报协议,是面向非连接的协议,它不与对方建立连接,而是直接把数据包发送过去.

二者特点:
TCP 特点: 使用流模式,保证数据传输顺序,面向连接,可靠,速度慢,不可以发送广播.发送需要通过3次”握手”建立连接,连接可靠.
3次握手过程: 
1) 第一次握手: 客户端将syn包(即同步包)(同步序列编号Synchronize Sequence Number)发送给服务器,服务器进入SYN_SEND状态 
2) 第二次握手: 服务器收到并确认客户端的syn包,然后也发送一个SYN包(SYN+ACK包),此时服务器进入 YN_RECV状态 
3) 第三次握手: 客户端收到服务器的 SYN+ACK包后,向服务器发送确认包ACK,发送完毕,客户端和服务器进入 ESTABLISHED(TCP连接成功)状态,完成三次握手.

(1)面向连接：采用C/S模型
(2)全双工
(3)安全可靠：
    ①流量控制：解决接收方不能不及时处理数据的问题
    ②拥塞控制：解决因网络通信延迟带来的数据丢失问题
    ③差错控制：解决数据被破坏、重复、时序和丢失的问题
(4)基于字节流



UDP 特点: 使用数据报格式,面向报文,无连接,对系统的资源要求少,不可靠,速度快,容易丢包,UDP不保证数据传输顺序,可以发送广播
</code></pre><h1 id="4-wan-lan-vpn">4.WAN、LAN、VPN</h1>
<pre><code>局域网(Local Area Network，LAN)：是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。
局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。
局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。

广域网 (Wide Area Network，WAN):是一种跨越大的、地域性的计算机网络的集合。通常跨越省、市，甚至一个国家。
广域网包括大大小小不同的子网，子网可以是局域网，也可以是小型的广域网。

虚拟专用网络(Virtual Private Network，VPN):虚拟专用网络功能是：在公用网络上建立专用网络，进行加密通讯。
在企业网络中有广泛应用。VPN 网关通过对数据包的加密和数据包目标地址的转换实现远程访问。
</code></pre><h1 id="5-socket-tcp-">5.什么是socket？简述基于tcp协议的套接字通信流程。</h1>
<pre><code>socket:网络套接字
</code></pre><h1 id="6-">6.解释什么是异步非阻塞？</h1>
<h1 id="7-socket-">7.什么是粘包？socket 中造成粘包的原因是什么？ 粘包的处理方式</h1>
<h1 id="8-">8.路由器和交换机的区别？</h1>
<pre><code>1.路由器工作在三层，交换机工作在二层
2.路由器通过ip寻址，交换机通过mac寻址
3.路由器提供防火墙功能，交换机没有此功能
</code></pre><h1 id="9-tcp-">9.简述tcp三次握手，四次分手过程；并说明为什么需要三次握手、四次分手以及每个步骤所处的状态。</h1>
<pre><code>三次握手：
    1.未建立连接时，客户端处于closed状态，服务端处于listen状态。建立连接时，客户端发送SYN包到服务器，并进入SYN_SENT状态，等待服务器确认。
    2.服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。
    3.客户端收到服务器的SYN+ACK包，就像服务端发送一个ACK确认包，此包发送完毕，客户端和服务器进入ESTAB_LISHED(TCP连接成功)状态，完成三次握手。

两次握手就足以建立连接，为什么还要第三次握手呢？
    两次握手就建立连接可能出现的问题：如果一个连接请求在网络中跑的慢，超时了，这时客户端会重发请求，但是这个跑的慢的请求最后还是跑到了，
    然后服务端就接收了两个连接请求，然后全部回应就会创建两个连接，浪费资源！如果加了第三次客户端确认，客户端在接受到一个服务端连接确认请求后，
    后面再接收到的连接确认请求就可以抛弃不管了。

四次分手：
    1.首先客户端请求关闭客户端到服务端方向的连接，这时客户端就要发送FIN包，进入FIN_WAIT1状态，表示要关闭一个方向的连接，
    此后客户端将不能像服务器发送数据，但可以接收服务端发来的数据。
    2.服务端接收到后是需要确认一下的，所以返回了一个ACK确认包，此时服务端会将未发送完的数据发送给客户端。服务端进入CLOSED_WAIT状态。客户端进入FIN_WAIT2状态。
    3.当所有数据发送完成后，服务端也向客户端发了一个 FIN+ACK 包，表示确认关闭。此时双方都不能在发送数据。服务端进入LAST_ACK状态。
    4.客户端接收到后发送ACK确认包，表示接受成功。但是此时TCP连接还没有释放，先进入TIME_WAIT状态。然后经过等待计时器设置的2MSL后，才进入到CLOSED状态。四次分手完成！

为什么需要四次分手才能安全断开连接？
    因为TCP连接是全双工的,即双方都要停止连接才能安全断开。当第一次分手时，客户端变为FIN_WAIT1状态，此时客户端将不能再给服务器发送数据，
    但仍可接收来自服务器的数据。当服务器将给客户端的数据发送完毕后，服务器确认断开，双方都不能在发送数据。客户端将进入time_wait状态。

为什么客户端要等待2MSL后才进入CLOSED状态？
    首先，MSL即Maximum Segment Lifetime，就是最大报文生存时间，是任何报文在网络上的存在的最长时间，超过这个时间报文将被丢弃。
    《TCP/IP详解》中是这样描述的：MSL是任何报文段被丢弃前在网络内的最长时间。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒、1分钟、2分钟等( /proc/sys/net/ipv4/tcp_fin_timeout参数)。
    TCP的TIME_WAIT需要等待2MSL，当TCP的一端发起主动关闭，三次挥手完成后发送第四次挥手的ACK包后就进入这个状态，
    等待2MSL时间主要目的是：防止最后一个ACK包对方没有收到，那么对方在超时后将重发第三次挥手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。
    在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可以继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。
</code></pre><h1 id="10-cookie-session-">10.请解释cookie和session的实现原理和区别</h1>
<pre><code>session原理：Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，
服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。
当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，
并和保存的所有Session ID进行对比，找到这个用户对应的Session。

cookie原理：如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了 cookie用户名(username),
那么，当你再次请求服务器的时候，浏览器会将username一块发送给服务器，这些变量有一定的特殊标记。服 务器会解释为 cookie变量。
cookie当不设置有效时间，关闭浏览器cookie就失效，设置有效时间会保存在磁盘中，下次登录仍然有效。

区别：
1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
2.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。
3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。
</code></pre><h1 id="11-http-https-ftp-smtp-pop3-ssh-dns-snmp-mysql-sql-">11.http、https、ftp、smtp、pop3、 ssh、dns、snmp、mysql、sql分别用的什么端口。</h1>
<pre><code>http:    80(tcp)
https:    443(tcp)
ftp:    21(tcp)
smtp:    25(tcp)
pop3:    110(tcp)
ssh:    22(tcp)
dns:    53(tcp/udp)
snmp:    ()
mysql:    3306
sql:    3389
telent:    23
DHCP:    67
tomcat:    8080
redis:    6379
oracle:    1521/1526
mongdb:    27017
</code></pre><h1 id="12-http-">12.说一下http状态码吧</h1>
<pre><code>1**：临时响应
2**：成功请求
3**：重定向
4**：客户端错误
5**：服务端错误 

200：请求被成功接收
304：请求的内容没有被修改过
403：客户端错误，没有权限，拒绝访问
404：客户端错误，访问的网页不存在
500：服务器内部错误，服务器未能实现合法的请求
503：服务器当前不能处理客户端的请求，过一段时间再试

502: Bad Gateway。主要是因为后端服务器,比如uswgi响应的内容是nginx无法理解的，那么就可能出现502。比如在后端服务器挂掉的情况下就会出现502
504: Gateway timeout. 主要是因为后端服务器处理任务太久，超过nginx的等待阈值。比如将nginx的请求等待时间设置得太小就可能出现504
503: Service unavailable.主要是因为瞬间并发量太大，导致后端服务器没有足够的资源去处理请求
</code></pre><h1 id="13-io-">13.IO原理（五种结构）</h1>
<pre><code>阻塞：从用户空间发起IO请求时就被阻塞，磁盘到内核缓存，内核缓存到应用缓存完成拷贝之后才被唤醒

非阻塞：当用户空间进程发起系统调用后（如read），会立即返回一个错误，但用户空间进程还是会一直（轮询）发起read，没完成就一直返回错误，直到完成磁盘到内核缓存的拷贝

IO复用：select(),poll(),epoll()

信号：当开启了信号驱动功能时，首先发起一个信号处理的系统调用，如sigaction()，这个系统调用会立即返回。
但数据在准备好时，会发送SIGIO信号，进程收到这个信号就知道数据准备好了，于是发起操作数据的系统调用，如read()。
在发起信号处理的系统调用后，进程不会被阻塞，但是在read()将数据从kernel buffer复制到app buffer时，进程是被阻塞的。

异步：当设置为异步IO模型时，httpd首先发起异步系统调用(如aio_read()，aio_write()等)，并立即返回。
这个异步系统调用告诉内核，不仅要准备好数据，还要把数据复制到app buffer中。
httpd从返回开始，直到数据复制到app buffer结束都不会被阻塞。当数据复制到app buffer结束，将发送一个信号通知httpd进程。
</code></pre><h1 id="14-">14.进程间通信方式</h1>
<pre><code>同一主机：
    管道（FIFO、PIPE）
    共享内存
    消息队列
    信号量
网络：
    socket（网络套接字）
</code></pre><h1 id="15-tcp-">15.TCP报头格式</h1>
<pre><code>源端口（16位）、目的端口（16位）
序列号（32位）：传输数据过程中，为每一个封包分配一个序号，保证网络传输数据的顺序性
确认号（32位）：用来确认确实有收到相关封包，内容表示期望收到下一个报文的序列号，用来解决丢包的问题
头部长度（4位）：标识该TCP头部有多少个32bit字节(4字节)。因为4位最大能表示15，所以TCP头部最长是60字节。保留位（6位）、标志位（6位）、滑动窗口（16位）
校验码（16位）、紧急指针（16位）
</code></pre><h1 id="16-tcp-">16.TCP的可靠连接是怎么实现的？</h1>
<pre><code>数据超时重传：发送发从发送数据开始计时，
数据确认应答：接收方收到后会发送一个ack应答包
每个传输的数据包分配序列号
</code></pre><h1 id="17-tcp-">17.能解释一下TCP的超时重传机制吗?</h1>
<pre><code>重新发送TCP片段的机制：超时重新发送和快速重新发送。 

超时重传：当发送方送出一个TCP片段后，将开始计时，等待该TCP片段的ACK回复。如果接收方正确接收到符合次序的片段，接收方会利用ACK片段回复发送方。
发送方得到ACK回复后，继续移动窗口，发送接下来的TCP片段。如果直到计时完成，发送方还是没有收到ACK回复，那么发送方推断之前发送的TCP片段丢失，
因此重新发送之前的TCP片段。这个计时等待的时间叫做重新发送超时时间(RTO, retransmission timeout)。
RTO时长取决于数据片段（发送发到接收方，接收方ack到发送方）往返时间(RTT, round trip time)。

快速重传：TCP协议规定，当接收方收到乱序片段的时候，需要重复发送ACK。比如接收到乱序片段9的时候，接收方需要回复ACK。回复号为8 (7+1)。
此后接收方如果继续收到乱序片段(序号不是8的片段)，将再次重复发送ACK=8。当发送方收到3个ACK=8的回复时，发送方推断片段8丢失。
即使此时片段8的计时器还没有超时，发送方会打断计时，直接重新发送片段8，这就是快速重新发送机制(fast-retransmission)。
快速重新发送机制利用重复的ACK来提示空洞的存在。当重复次数达到阈值时，认为空洞对应的片段在网络中丢失。快速重新发送机制提高了检测丢失片段的效率，
往往可以在超时之前探测到丢失片段，并重复发送丢失的片段。
</code></pre><h1 id="18-tcp-">18.TCP拥塞控制及方法</h1>
<pre><code>TCP除了通过控制滑窗(sliding window)大小来控制发送速率，以实现TCP流量控制。TCP还会维护一个congestion window size，以根据网络状况来调整滑窗大小。
真实滑窗大小取这两个滑窗限制的最小值，从而同时满足两个限制 (流量控制和堵塞控制)。

congestion window总是处于两种状态的一个。这两种状态是: 慢起动(slow start)和堵塞避免(congestion avoidance)。

Congestion window从slow start的状态开始。Slow start的特点是初始速率低，但速率不断倍增。每次进入到slow start状态时，cwnd都需要重置为初始值1。
发送方每接收到一个正确的ACK，就会将congestion window增加1，从而实现速率的倍增(由于累计ACK，速率增长可能会小于倍增)。

当congestion window的大小达到某个阈值ssthresh时，congestion进入到congestion avoidance状态。发送速率会继续增长。发送方在每个窗户所有片段成功传输后，
将窗口尺寸增加1(实际上就是每个RTT增加1)。所以在congestion avoidance下，cwnd线性增长，增长速率慢。

如果在congestion avoidance下有片段丢失，重新回到slow start状态，并将ssthresh更新为cwnd的一半。
</code></pre><h1 id="19-tcp-ip-">19.TCP/IP的流量控制</h1>
<pre><code>通过滑动窗口控制流量

发送发滑动窗口分为：发送但没收到ack回复，等待发送
接收方滑动窗口分为：收到数据且已发送ack但没给进程读取，收到数据但没发送ack，没有收到数据

当接收方进程过于忙碌，不能及时取走划窗中的数据，接收方划窗就会变小，并在TCP头部的window size大小进行调整，接收方会同步划窗大小，从而实现流量控制。
</code></pre><h1 id="20-time_wait-">20.如何处理time_wait状态</h1>
<pre><code>编辑内核文件/etc/sysctl.conf，加入以下内容：

net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间
然后执行 /sbin/sysctl -p 让参数生效.

/etc/sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。
简单来说，就是打开系统的TIMEWAIT重用和快速回收。

如果以上配置调优后性能还不理想，可继续修改一下配置：

复制代码
~]# vi /etc/sysctl.conf
net.ipv4.tcp_keepalive_time = 1200 
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。

net.ipv4.ip_local_port_range = 1024 65000 
#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。

net.ipv4.tcp_max_syn_backlog = 8192 
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。

net.ipv4.tcp_max_tw_buckets = 5000 
#表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。
默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。
此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。
</code></pre><h1 id="21-ip-ip-">21.说说保留的IP字段是哪些,IP地址的分类</h1>
<pre><code>IP(Internet protocol)地址：网络号+主机号

    IPv4:32bits
        8bits:8bits:8bits:8bits
            0-255
            0.0.0.0-255.255.255.255

        IP地址分类
            A类：
                第一段为网络号，后三段为主机号
                网络号：
                    0 000 0000 - 0 111 1111 ：1-127
                网络数量：2^7 （126, 127为本地回环接口）
                每个网络中的主机数量：2^24-2,    0.0.0,    255.255.255
                默认    子网掩码：255.0.0.0
                    用于与IP地址按位进行&quot;与&quot;运算，从而取出其网络地址
                    1.3.2.1/255.0.0.0=1.0.0.0
                    1.3.2.1/255.255.0.0=1.3.0.0    
                私网地址：10.0.0.0/255.0.0.0

            B类：
                前两段为网络号，后两段为主机号
                网络号：
                    10 00 0000 - 10 11 1111 ：128-191
                网络数：2^14
                每个网络中的主机数量：2^16-2
                默认子网掩码：255.255.0.0
                私网地址：172.16.0.0-172.31.0.0

            C类：
                前三段为网络号，最后一段为主机号
                网络号：
                    110 0 0000 - 110 1 1111 ：192-223
                网络数：2^21
                每个网络中的主机号：2^8-2
                默认子网掩码：255.255.255.0,24(24个1)

            D类：组播
                1110 0000 - 1110 1111:224-239

            E类：科研
                240-255
</code></pre><h1 id="22-http-">22.http协议你所知道的所有方法</h1>
<pre><code>1    GET    请求指定的页面信息，并返回实体主体。
2    HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
3    POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
4    PUT    从客户端向服务器传送的数据取代指定的文档的内容。
5    DELETE    请求服务器删除指定的页面。
6    CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
7    OPTIONS    允许客户端查看服务器的性能。
8    TRACE    回显服务器收到的请求，主要用于测试或诊断。
</code></pre><h1 id="23-https-ca-ca-ca-">23.谈谈你对Https协议的理解？对称加密与非对称加密?CA的作用？工作方式？它是如何保证身份不被伪造的？CA证书中有些什么内容？CA机构持有的是公钥还是私钥？</h1>
<pre><code>https+ssl

对称加密   ：加密解密使用同一密钥，加解密速度快。AES/DES/3DES
非对称加密 ：使用公私钥配对加解密，速度慢。公钥是从私钥中提取出来的，一般拿对方公钥加密来保证数据安全性，拿自己的私钥加密来证明数据来源的身份。RSA/DSA            
单向加密   ：不算是加密，也常称为散列运算，用于生成独一无二的校验码(或称为指纹、特征码)来保证数据的完整性和一致性，如MD5、SHA。
            具有雪崩效应，任何一点数据的改变，生成的校验码值变化非常大。


互联网数据安全可靠的条件：
    1.数据来源可信，即数据发送者身份可信。
    2.数据具备完整性，即数据未被修改过。
    3.数据安全性，即数据不会被泄漏，他人截获后无法解密。

数字签名：保证数据的完整性、一致性以及数据来源的可靠性。
        发送方：单向加密提取文件校验码，私钥加密校验码。
        接收方：发送方公钥解密得到校验码，使用相同单向加密算法对文件提取校验码，若与解密得到的校验码相同，说明数据安全。

数据加密传输：

    http://www.cnblogs.com/f-ck-need-u/p/6089523.html
</code></pre><h1 id="24-ping-">24.怎么查看两台服务器之间的网络是不是正常的，服务器是禁ping的？</h1>
<pre><code>不能用ping，那可以用telnet对方服务器的端口、或者互相访问对方打开的服务。
</code></pre><h1 id="25-">25.比如我访问百度网站，有什么方法可以跟踪经过了哪些网络节点？</h1>
<pre><code>这个太简单了吧，干运维必备的网络排查技能。用tracert命令就可以跟踪，主要是查询本机到另一个主机经过的路由跳数及数据延迟情况。
然后你也可以把具体跟踪后输出的信息也说出来，你能说出来都是为你加分的。
</code></pre><h1 id="26-http-">26.HTTP协议(头结构，几种请求方法，缓存机制，各版本的区别)</h1>
<h1 id="27-https-http-ssl-">27.HTTPS协议，和HTTP协议的区别，密钥协商的过程，SSL机制</h1>
<h1 id="28-dns-">28.DNS协议</h1>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
